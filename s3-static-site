#!/usr/bin/env bash

########################################################################
# Function to clean up temporary files
########################################################################
cleanup() {
########################################################################
    echo "üßπ Cleaning up temporary files..." | tee -a "$LOG_FILE"
    
    TEMP_FILES=(${TEMP_FILES[@]:-})

    for temp_file in "${TEMP_FILES[@]}"; do
        if [[ -f "$temp_file" ]]; then
            rm -f "$temp_file"
            echo "‚úÖ Removed: $temp_file" | tee -a "$LOG_FILE"
        fi
    done
}
########################################################################
run_command() {
########################################################################
    echo "üîπ Running: $*" | tee -a "$LOG_FILE"
    OUTPUT=$("$@" 2>&1)
    EXIT_CODE=$?

    echo "$OUTPUT" >> "$LOG_FILE"

    if [ $EXIT_CODE -ne 0 ]; then
        echo "‚ùå ERROR: Command failed: $*" | tee -a "$LOG_FILE"
        echo "üîç Check logs for details: $LOG_FILE" | tee -a "$LOG_FILE"
        echo "üìå TIP: Since this script is idempotent, you can re-run it safely to retry." | tee -a "$LOG_FILE"
        exit 1
    fi
}

########################################################################
# Function to display help message
########################################################################
usage() {
########################################################################
    echo "Usage: $0 -b BUCKET_NAME -p AWS_PROFILE [-r AWS_REGION] [-o OAC_NAME]"
    echo ""
    echo "Options:"
    echo "  -b    (Required) S3 Bucket Name"
    echo "  -p    (Required) AWS Profile (or set AWS_PROFILE in the environment)"
    echo "  -r    AWS Region (default: us-east-1)"
    echo "  -o    CloudFront OAC Name (default: Derived from Bucket Name)"
    echo "  -h    Display this help message"
    exit 1
}


########################################################################
# main script starts here
########################################################################

set -euo pipefail

# List of temp files to be cleaned up
TEMP_FILES=()

# Register cleanup function to run on script exit or error
trap cleanup EXIT

# Ensure log directory exists
LOG_DIR="$(pwd)/logs"
mkdir -p "$LOG_DIR"

# Generate a unique log file using timestamp + process ID (PID)
LOG_FILE="$LOG_DIR/deploy_$(date +'%Y%m%d_%H%M%S')_$$.log"

# Ensure log file exists before creating a symlink
touch "$LOG_FILE"

# Remove existing symlink in the CWD if it exists
if [ -L "./deploy.log" ]; then
    rm "./deploy.log"
fi

# Create a new symlink in the current working directory
ln -s "$LOG_FILE" "./deploy.log"

echo "‚úÖ Symlink created: ./deploy.log -> $LOG_FILE" | tee -a "$LOG_FILE"

# Default Values
AWS_REGION="us-east-1"
BUCKET_NAME=""
OAC_NAME=""
AWS_PROFILE="${AWS_PROFILE:-}"  # Use environment variable if set

# Parse command-line options using `getopt`
OPTIONS=$(getopt -o b:p:r:o:h --long bucket:,profile:,region:,oac-name:,help -- "$@")
if [ $? -ne 0 ]; then
    usage
fi

eval set -- "$OPTIONS"

# Assign values based on user input
while true; do
    case "$1" in
        -b | --bucket )     BUCKET_NAME="$2"; shift 2 ;;
        -p | --profile )    AWS_PROFILE="$2"; shift 2 ;;
        -r | --region )     AWS_REGION="$2"; shift 2 ;;
        -o | --oac-name )   OAC_NAME="$2"; shift 2 ;;
        -h | --help )       usage ;;
        -- ) shift; break ;;
        * ) break ;;
    esac
done

# Validate required inputs
if [ -z "$BUCKET_NAME" ]; then
    echo "‚ùå Error: S3 Bucket Name is required." | tee -a "$LOG_FILE"
    usage
fi

if [ -z "$AWS_PROFILE" ]; then
    echo "‚ùå Error: AWS Profile is required. Either pass -p <profile> or set AWS_PROFILE in the environment." | tee -a "$LOG_FILE"
    usage
fi

# Derive OAC_NAME from BUCKET_NAME if not provided
if [ -z "$OAC_NAME" ]; then
    OAC_NAME="${BUCKET_NAME}-OAC"
fi

# Print selected options
echo "üöÄ Running script with the following options:" | tee -a "$LOG_FILE"
echo "   üìå AWS Region: $AWS_REGION" | tee -a "$LOG_FILE"
echo "   üìå S3 Bucket: $BUCKET_NAME" | tee -a "$LOG_FILE"
echo "   üìå AWS Profile: $AWS_PROFILE" | tee -a "$LOG_FILE"
echo "   üìå OAC Name: $OAC_NAME" | tee -a "$LOG_FILE"
echo "" | tee -a "$LOG_FILE"


# Check if the bucket already exists
BUCKET_EXISTS=$(aws s3api head-bucket --bucket $BUCKET_NAME --profile $AWS_PROFILE 2>&1 || true)

if echo "$BUCKET_EXISTS" | grep -q '404'; then
    echo "üõ†Ô∏è Bucket does not exist. Creating..."
    BUCKET_CONFIGURATION=$([ "$AWS_REGION" != "us-east-1" ] && echo "--create-bucket-configuration LocationConstraint=$AWS_REGION")
    run_command aws s3api create-bucket --bucket $BUCKET_NAME --region $AWS_REGION $BUCKET_CONFIGURATION --profile $AWS_PROFILE
elif echo "$BUCKET_EXISTS" | grep -q '403'; then
    echo "‚ùå Error: Bucket name exists but you do not have permission to access it."
    exit 1
elif echo "$BUCKET_EXISTS" | grep -q '301'; then
    echo "‚ùå Error: Bucket exists in a different region. Please check the region."
    exit 1
else
    echo "‚úÖ Bucket already exists: $BUCKET_NAME" | tee -a "$LOG_FILE"
fi

BUCKET_REGION=$(aws s3api get-bucket-location --bucket "$BUCKET_NAME" --profile "$AWS_PROFILE" --query "LocationConstraint" --output text 2>> "$LOG_FILE" || true)

if [ "$BUCKET_REGION" = "None" ]; then
    BUCKET_REGION="us-east-1"  # AWS returns null for us-east-1
fi

if [ "$BUCKET_REGION" != "$AWS_REGION" ]; then
    echo "‚ùå Error: Bucket exists, but in a different region ($BUCKET_REGION instead of $AWS_REGION)." | tee -a "$LOG_FILE"
    exit 1
fi

# Create JSON file for public access block
PUBLIC_ACCESS_JSON=$(mktemp)
TEMP_FILES+=("$PUBLIC_ACCESS_JSON")

cat > "$PUBLIC_ACCESS_JSON" <<EOF
{
  "BlockPublicAcls": true,
  "IgnorePublicAcls": true,
  "BlockPublicPolicy": true,
  "RestrictPublicBuckets": true
}
EOF

# Run the command using the JSON file
run_command aws s3api put-public-access-block --bucket $BUCKET_NAME \
    --public-access-block-configuration file://$PUBLIC_ACCESS_JSON --profile $AWS_PROFILE

# Create CloudFront Origin Access Control (OAC) using a temp file
OAC_CONFIG=$(mktemp)
TEMP_FILES+=("$OAC_CONFIG")

cat > "$OAC_CONFIG" <<EOF
{
  "Name": "$OAC_NAME",
  "Description": "OAC for Private S3 Website",
  "SigningProtocol": "sigv4",
  "SigningBehavior": "always",
  "OriginAccessControlOriginType": "s3"
}
EOF

# Check if OAC already exists
EXISTING_OAC_ID=$(aws cloudfront list-origin-access-controls 2>> "$LOG_FILE" \
    --query "OriginAccessControlList.Items[?Name=='$OAC_NAME'].Id" --output text --profile $AWS_PROFILE)

if [ -n "$EXISTING_OAC_ID" ]; then
    echo "‚úÖ CloudFront OAC already exists. Using existing OAC ID: $EXISTING_OAC_ID" | tee -a "$LOG_FILE"
    OAC_ID=$EXISTING_OAC_ID
else
    echo "üõ†Ô∏è Creating a new CloudFront OAC..." | tee -a "$LOG_FILE"
    OAC_ID=$(aws cloudfront create-origin-access-control 2>> "$LOG_FILE" \
        --origin-access-control-config file://$OAC_CONFIG \
        --query "OriginAccessControl.Id" --output text --profile $AWS_PROFILE)
    
    if [ -z "$OAC_ID" ]; then
        echo "‚ùå Failed to create CloudFront OAC. Exiting." | tee -a "$LOG_FILE"
        exit 1
    fi
fi

# Create CloudFront Distribution using a temp file
CF_DISTRIBUTION_CONFIG=$(mktemp)
TEMP_FILES+=("$CF_DISTRIBUTION_CONFIG")
callerReference=$(date +%s)

cat > "$CF_DISTRIBUTION_CONFIG" <<EOF
{
  "CallerReference": "$callerReference",
  "Comment": "CloudFront Distribution for Private S3 Website",
  "Enabled": true,
  "Origins": {
    "Quantity": 1,
    "Items": [
      {
        "Id": "S3-$BUCKET_NAME",
        "DomainName": "$BUCKET_NAME.s3.amazonaws.com",
        "OriginAccessControlId": "$OAC_ID",
        "S3OriginConfig": {
          "OriginAccessIdentity": ""
        }
      }
    ]
  },
  "DefaultCacheBehavior": {
    "TargetOriginId": "S3-$BUCKET_NAME",
    "ViewerProtocolPolicy": "redirect-to-https",
    "AllowedMethods": {
      "Quantity": 2,
      "Items": ["GET", "HEAD"]
    },
    "ForwardedValues": {
      "QueryString": false,
      "Cookies": {
        "Forward": "none"
      }
    },
    "MinTTL": 0,
    "DefaultTTL": 86400,
    "MaxTTL": 31536000
  }
}
EOF

# Check if CloudFront Distribution Already Exists for this S3 Bucket
EXISTING_DISTRIBUTION_ID=$(aws cloudfront list-distributions \
    --query "DistributionList.Items[?Origins.Items[0].DomainName==\`$BUCKET_NAME.s3.amazonaws.com\`].Id" \
    --output text --profile $AWS_PROFILE 2>>$LOG_FILE)

if [ -n "$EXISTING_DISTRIBUTION_ID" ]; then
    echo "‚úÖ CloudFront distribution already exists: $EXISTING_DISTRIBUTION_ID" | tee -a "$LOG_FILE"
    DISTRIBUTION_ID="$EXISTING_DISTRIBUTION_ID"
else
    echo "üõ†Ô∏è Creating a new CloudFront Distribution..." | tee -a "$LOG_FILE"

    # Create CloudFront Distribution using `run_command`
    DISTRIBUTION_ID=$(aws cloudfront create-distribution \
        --distribution-config file://"$CF_DISTRIBUTION_CONFIG" \
        --query "Distribution.Id" --output text --profile $AWS_PROFILE 2>>$LOG_FILE)

    if [ -z "$DISTRIBUTION_ID" ]; then
        echo "‚ùå Failed to create CloudFront Distribution. Exiting." | tee -a "$LOG_FILE"
        exit 1
    fi

    echo "‚úÖ Successfully created CloudFront Distribution: $DISTRIBUTION_ID" | tee -a "$LOG_FILE"
fi

AWS_ACCOUNT=$(aws sts get-caller-identity --query 'Account' --output text --profile $AWS_PROFILE)

EXISTING_POLICY=$(aws s3api get-bucket-policy --bucket "$BUCKET_NAME" --profile "$AWS_PROFILE" --output text 2>>$LOG_FILE || true)

if [ -n "$EXISTING_POLICY" ]; then
    echo "‚úÖ S3 Bucket Policy already exists. Skipping policy application." | tee -a "$LOG_FILE"
else
    echo "üõ†Ô∏è Applying S3 Bucket Policy..." | tee -a "$LOG_FILE"

    BUCKET_POLICY=$(mktemp)
    TEMP_FILES+=("$BUCKET_POLICY")

    cat >$BUCKET_POLICY <<EOF
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "cloudfront.amazonaws.com"
      },
      "Action": "s3:GetObject",
      "Resource": "arn:aws:s3:::$BUCKET_NAME/*",
      "Condition": {
        "StringEquals": {
          "AWS:SourceArn": "arn:aws:cloudfront::$AWS_ACCOUNT:distribution/$DISTRIBUTION_ID"
        }
      }
    }
  ]
}
EOF

    run_command aws s3api put-bucket-policy --bucket $BUCKET_NAME --policy file://$BUCKET_POLICY --profile $AWS_PROFILE
fi

echo "Distribution id: $DISTRIBUTION_ID"

CF_DOMAIN_NAME=$(aws cloudfront get-distribution \
    --id "$DISTRIBUTION_ID" \
    --query "Distribution.DomainName" --output text --profile "$AWS_PROFILE")


echo "‚úÖ CloudFront Distribution is accessible at: https://$CF_DOMAIN_NAME" | tee -a "$LOG_FILE"

# Get the Public IP of the VPC (Ensure Only One IP)
PUBLIC_IPS=$(aws ec2 describe-nat-gateways  \
    --query "NatGateways[].NatGatewayAddresses[].PublicIp" \
    --output text --profile $AWS_PROFILE 2>>$LOG_FILE)

IP_COUNT=$(echo "$PUBLIC_IPS" | wc -w)

if [ "$IP_COUNT" -eq 0 ]; then
    echo "‚ùå Error: No public IP found for your VPC's NAT Gateway. Exiting." | tee -a "$LOG_FILE"
    exit 1
elif [ "$IP_COUNT" -gt 1 ]; then
    echo "‚ùå Error: Multiple public IPs detected. Please specify which one to use. Exiting." | tee -a "$LOG_FILE"
    echo "Detected IPs: $PUBLIC_IPS" | tee -a "$LOG_FILE"
    exit 1
else
    PUBLIC_IP="$PUBLIC_IPS"
    echo "‚úÖ Using VPC Public IP: $PUBLIC_IP" | tee -a "$LOG_FILE"
fi

# Check if WAF IP Set Already Exists
EXISTING_IPSET_ARN=$(aws wafv2 list-ip-sets --scope CLOUDFRONT --region $AWS_REGION \
    --query "IPSets[?Name=='AllowVPCOnly'].ARN" --output text --profile $AWS_PROFILE 2>>$LOG_FILE)

if [ -n "$EXISTING_IPSET_ARN" ]; then
    echo "‚úÖ WAF IP Set already exists: $EXISTING_IPSET_ARN" | tee -a "$LOG_FILE"
    IPSET_ARN="$EXISTING_IPSET_ARN"
else
    echo "üõ†Ô∏è Creating a new WAF IP Set for VPC access..." | tee -a "$LOG_FILE"
    IPSET_ARN=$(aws wafv2 create-ip-set --name "AllowVPCOnly" \
        --scope CLOUDFRONT --region $AWS_REGION \
        --addresses "$PUBLIC_IP/32" \
        --ip-address-version IPV4 --query "Summary.ARN" --output text --profile $AWS_PROFILE 2>>$LOG_FILE)

    if [ -z "$IPSET_ARN" ]; then
        echo "‚ùå Failed to create WAF IP Set. Exiting." | tee -a "$LOG_FILE"
        exit 1
    fi
fi

echo "‚è≥ Waiting for WAF IP Set to be available..." | tee -a "$LOG_FILE"

MAX_ATTEMPTS=10
SLEEP_INTERVAL=5
ATTEMPTS=0

while true; do
    IPSET_STATUS=$(aws wafv2 get-ip-set --name "AllowVPCOnly" --scope CLOUDFRONT --region "$AWS_REGION" \
        --query "LockToken" --output text --profile "$AWS_PROFILE" 2>/dev/null)

    if [ -n "$IPSET_STATUS" ]; then
        echo "‚úÖ WAF IP Set is ready!" | tee -a "$LOG_FILE"
        break
    fi

    if [ "$ATTEMPTS" -ge "$MAX_ATTEMPTS" ]; then
        echo "‚ùå Error: WAF IP Set did not become available in time. Exiting." | tee -a "$LOG_FILE"
        exit 1
    fi

    echo "‚è≥ Still waiting for WAF IP Set... Attempt $((ATTEMPTS + 1))/$MAX_ATTEMPTS" | tee -a "$LOG_FILE"
    sleep "$SLEEP_INTERVAL"
    ATTEMPTS=$((ATTEMPTS + 1))
done

# Create Web ACL JSON Config
WEB_ACL_JSON=$(mktemp)
TEMP_FILES+=("$WEB_ACL_JSON")

cat > "$WEB_ACL_JSON" <<EOF
{
  "Name": "RestrictToVPC",
  "Scope": "CLOUDFRONT",
  "DefaultAction": { "Block": {} },
  "Rules": [
    {
      "Name": "AllowVPCOnly",
      "Priority": 0,
      "Action": { "Allow": {} },
      "Statement": {
        "IPSetReferenceStatement": { "ARN": "$IPSET_ARN" }
      },
      "VisibilityConfig": {
        "SampledRequestsEnabled": true,
        "CloudWatchMetricsEnabled": true,
        "MetricName": "AllowVPCOnly"
      }
    }
  ],
  "VisibilityConfig": {
    "SampledRequestsEnabled": true,
    "CloudWatchMetricsEnabled": true,
    "MetricName": "RestrictToVPC"
  }
}
EOF

# Check if WAF Web ACL Exists or Create a New One
EXISTING_WEB_ACL_ARN=$(aws wafv2 list-web-acls --scope CLOUDFRONT --region $AWS_REGION \
    --query "WebACLs[?Name=='RestrictToVPC'].ARN" --output text --profile $AWS_PROFILE 2>>$LOG_FILE)

if [ -n "$EXISTING_WEB_ACL_ARN" ]; then
    echo "‚úÖ WAF Web ACL already exists: $EXISTING_WEB_ACL_ARN" | tee -a "$LOG_FILE"
    WEB_ACL_ARN="$EXISTING_WEB_ACL_ARN"
else
    echo "üõ†Ô∏è Creating a new WAF Web ACL..." | tee -a "$LOG_FILE"
    WEB_ACL_ARN=$(aws wafv2 create-web-acl --cli-input-json file://"$WEB_ACL_JSON" \
        --query "Summary.ARN" --output text --profile $AWS_PROFILE 2>>$LOG_FILE)

    if [ -z "$WEB_ACL_ARN" ]; then
        echo "‚ùå Failed to create WAF Web ACL. Exiting." | tee -a "$LOG_FILE"
        exit 1
    fi
fi

# Attach WAF Web ACL to CloudFront
echo "üõ†Ô∏è Attaching WAF Web ACL to CloudFront Distribution..." | tee -a "$LOG_FILE"

run_command aws cloudfront update-distribution --id "$DISTRIBUTION_ID" \
    --web-acl-id "$WEB_ACL_ARN" --profile $AWS_PROFILE

echo "‚úÖ Successfully attached WAF Web ACL to CloudFront Distribution: $DISTRIBUTION_ID" | tee -a "$LOG_FILE"
